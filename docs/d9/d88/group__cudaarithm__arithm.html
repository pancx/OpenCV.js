<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenCV: Arithm Operations on Matrices</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">3.3.0-dev</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<script type="text/javascript">
//<![CDATA[
function getLabelName(innerHTML) {
    var str = innerHTML.toLowerCase();
    // Replace all '+' with 'p'
    str = str.split('+').join('p');
    // Replace all ' ' with '_'
    str = str.split(' ').join('_');
    // Replace all '#' with 'sharp'
    str = str.split('#').join('sharp');
    // Replace other special characters with 'ascii' + code
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (!(charCode == 95 || (charCode > 96 && charCode < 123) || (charCode > 47 && charCode < 58)))
            str = str.substr(0, i) + 'ascii' + charCode + str.substr(i + 1);
    }
    return str;
}
function addToggle() {
    var $getDiv = $('div.newInnerHTML').last();
    var buttonName = $getDiv.html();
    var label = getLabelName(buttonName.trim());
    $getDiv.attr("title", label);
    $getDiv.hide();
    $getDiv = $getDiv.next();
    $getDiv.attr("class", "toggleable_div label_" + label);
    $getDiv.hide();
}
//]]>
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Arithm Operations on Matrices<div class="ingroups"><a class="el" href="../../d0/de1/group__core.html">Core functionality</a> &raquo; <a class="el" href="../../d2/d3c/group__core__opengl.html">OpenGL interoperability</a> &raquo; <a class="el" href="../../d1/d1e/group__cuda.html">CUDA-accelerated Computer Vision</a> &raquo; <a class="el" href="../../d5/d8e/group__cudaarithm.html">Operations on Matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d25/classcv_1_1cuda_1_1Convolution.html">cv::cuda::Convolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for convolution (or cross-correlation) operator. :  <a href="../../d4/d25/classcv_1_1cuda_1_1Convolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/de5/classcv_1_1cuda_1_1DFT.html">cv::cuda::DFT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="../../dc/de5/classcv_1_1cuda_1_1DFT.html" title="Base class for DFT operator as a cv::Algorithm. : ">DFT</a> operator as a <a class="el" href="../../d3/d46/classcv_1_1Algorithm.html" title="This is a base class for all more or less complex algorithms in OpenCV. ">cv::Algorithm</a>. :  <a href="../../dc/de5/classcv_1_1cuda_1_1DFT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2695e05ef624bf3ce03cfbda383a821d"><td class="memItemLeft" align="right" valign="top">Ptr&lt; Convolution &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d88/group__cudaarithm__arithm.html#ga2695e05ef624bf3ce03cfbda383a821d">cv::cuda::createConvolution</a> (Size user_block_size=Size())</td></tr>
<tr class="memdesc:ga2695e05ef624bf3ce03cfbda383a821d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates implementation for <a class="el" href="../../d4/d25/classcv_1_1cuda_1_1Convolution.html" title="Base class for convolution (or cross-correlation) operator. : ">cuda::Convolution</a> .  <a href="../../d9/d88/group__cudaarithm__arithm.html#ga2695e05ef624bf3ce03cfbda383a821d">More...</a><br /></td></tr>
<tr class="separator:ga2695e05ef624bf3ce03cfbda383a821d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f72d063b73c8bb995678525eb076f10"><td class="memItemLeft" align="right" valign="top">Ptr&lt; DFT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d88/group__cudaarithm__arithm.html#ga0f72d063b73c8bb995678525eb076f10">cv::cuda::createDFT</a> (Size dft_size, int flags)</td></tr>
<tr class="memdesc:ga0f72d063b73c8bb995678525eb076f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates implementation for <a class="el" href="../../dc/de5/classcv_1_1cuda_1_1DFT.html" title="Base class for DFT operator as a cv::Algorithm. : ">cuda::DFT</a>.  <a href="../../d9/d88/group__cudaarithm__arithm.html#ga0f72d063b73c8bb995678525eb076f10">More...</a><br /></td></tr>
<tr class="separator:ga0f72d063b73c8bb995678525eb076f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadea99cb15a715c983bcc2870d65a2e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d88/group__cudaarithm__arithm.html#gadea99cb15a715c983bcc2870d65a2e78">cv::cuda::dft</a> (InputArray src, OutputArray dst, Size dft_size, int flags=0, Stream &amp;stream=Stream::Null())</td></tr>
<tr class="memdesc:gadea99cb15a715c983bcc2870d65a2e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a forward or inverse discrete Fourier transform (1D or 2D) of the floating point matrix.  <a href="../../d9/d88/group__cudaarithm__arithm.html#gadea99cb15a715c983bcc2870d65a2e78">More...</a><br /></td></tr>
<tr class="separator:gadea99cb15a715c983bcc2870d65a2e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42efe211d7a43bbc922da044c4f17130"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d88/group__cudaarithm__arithm.html#ga42efe211d7a43bbc922da044c4f17130">cv::cuda::gemm</a> (InputArray src1, InputArray src2, double alpha, InputArray src3, double beta, OutputArray dst, int flags=0, Stream &amp;stream=Stream::Null())</td></tr>
<tr class="memdesc:ga42efe211d7a43bbc922da044c4f17130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs generalized matrix multiplication.  <a href="../../d9/d88/group__cudaarithm__arithm.html#ga42efe211d7a43bbc922da044c4f17130">More...</a><br /></td></tr>
<tr class="separator:ga42efe211d7a43bbc922da044c4f17130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5704c25b8be4f19da812e6d98c8ee464"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d88/group__cudaarithm__arithm.html#ga5704c25b8be4f19da812e6d98c8ee464">cv::cuda::mulAndScaleSpectrums</a> (InputArray src1, InputArray src2, OutputArray dst, int flags, float scale, bool conjB=false, Stream &amp;stream=Stream::Null())</td></tr>
<tr class="memdesc:ga5704c25b8be4f19da812e6d98c8ee464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a per-element multiplication of two Fourier spectrums and scales the result.  <a href="../../d9/d88/group__cudaarithm__arithm.html#ga5704c25b8be4f19da812e6d98c8ee464">More...</a><br /></td></tr>
<tr class="separator:ga5704c25b8be4f19da812e6d98c8ee464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e8900d67c4f59bdc137a0495206cd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d88/group__cudaarithm__arithm.html#gab3e8900d67c4f59bdc137a0495206cd8">cv::cuda::mulSpectrums</a> (InputArray src1, InputArray src2, OutputArray dst, int flags, bool conjB=false, Stream &amp;stream=Stream::Null())</td></tr>
<tr class="memdesc:gab3e8900d67c4f59bdc137a0495206cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a per-element multiplication of two Fourier spectrums.  <a href="../../d9/d88/group__cudaarithm__arithm.html#gab3e8900d67c4f59bdc137a0495206cd8">More...</a><br /></td></tr>
<tr class="separator:gab3e8900d67c4f59bdc137a0495206cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga2695e05ef624bf3ce03cfbda383a821d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ptr&lt;Convolution&gt; cv::cuda::createConvolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0">Size</a>&#160;</td>
          <td class="paramname"><em>user_block_size</em> = <code><a class="el" href="../../dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0">Size</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates implementation for <a class="el" href="../../d4/d25/classcv_1_1cuda_1_1Convolution.html" title="Base class for convolution (or cross-correlation) operator. : ">cuda::Convolution</a> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_block_size</td><td>Block size. If you leave default value Size(0,0) then automatic estimation of block size will be used (which is optimized for speed). By varying user_block_size you can reduce memory requirements at the cost of speed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0f72d063b73c8bb995678525eb076f10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ptr&lt;DFT&gt; cv::cuda::createDFT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0">Size</a>&#160;</td>
          <td class="paramname"><em>dft_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates implementation for <a class="el" href="../../dc/de5/classcv_1_1cuda_1_1DFT.html" title="Base class for DFT operator as a cv::Algorithm. : ">cuda::DFT</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dft_size</td><td>The image size. </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags:<ul>
<li><b>DFT_ROWS</b> transforms each individual row of the source matrix.</li>
<li><b>DFT_SCALE</b> scales the result: divide it by the number of elements in the transform (obtained from dft_size ).</li>
<li><b>DFT_INVERSE</b> inverts <a class="el" href="../../dc/de5/classcv_1_1cuda_1_1DFT.html" title="Base class for DFT operator as a cv::Algorithm. : ">DFT</a>. Use for complex-complex cases (real-complex and complex-real cases are always forward and inverse, respectively).</li>
<li><b>DFT_COMPLEX_INPUT</b> Specifies that inputs will be complex with 2 channels.</li>
<li><b>DFT_REAL_OUTPUT</b> specifies the output as real. The source matrix is the result of real-complex transform, so the destination matrix must be real. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadea99cb15a715c983bcc2870d65a2e78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::cuda::dft </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gab1371a23c90d5f4725ea98240377d7a1">InputArray</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0">Size</a>&#160;</td>
          <td class="paramname"><em>dft_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html">Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html#a680af5adfeeb1cdaa5b7b13f680c0131">Stream::Null</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a forward or inverse discrete Fourier transform (1D or 2D) of the floating point matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source matrix (real or complex). </td></tr>
    <tr><td class="paramname">dst</td><td>Destination matrix (real or complex). </td></tr>
    <tr><td class="paramname">dft_size</td><td>Size of a discrete Fourier transform. </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags:<ul>
<li><b>DFT_ROWS</b> transforms each individual row of the source matrix.</li>
<li><b>DFT_SCALE</b> scales the result: divide it by the number of elements in the transform (obtained from dft_size ).</li>
<li><b>DFT_INVERSE</b> inverts <a class="el" href="../../dc/de5/classcv_1_1cuda_1_1DFT.html" title="Base class for DFT operator as a cv::Algorithm. : ">DFT</a>. Use for complex-complex cases (real-complex and complex-real cases are always forward and inverse, respectively).</li>
<li><b>DFT_COMPLEX_INPUT</b> Specifies that input is complex input with 2 channels.</li>
<li><b>DFT_REAL_OUTPUT</b> specifies the output as real. The source matrix is the result of real-complex transform, so the destination matrix must be real. </li>
</ul>
</td></tr>
    <tr><td class="paramname">stream</td><td><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a> for the asynchronous version.</td></tr>
  </table>
  </dd>
</dl>
<p>Use to handle real matrices ( CV32FC1 ) and complex matrices in the interleaved format ( CV32FC2 ).</p>
<p>The source matrix should be continuous, otherwise reallocation and data copying is performed. The function chooses an operation mode depending on the flags, size, and channel count of the source matrix:</p>
<ul>
<li>If the source matrix is complex and the output is not specified as real, the destination matrix is complex and has the dft_size size and CV_32FC2 type. The destination matrix contains a full result of the <a class="el" href="../../dc/de5/classcv_1_1cuda_1_1DFT.html" title="Base class for DFT operator as a cv::Algorithm. : ">DFT</a> (forward or inverse).</li>
<li>If the source matrix is complex and the output is specified as real, the function assumes that its input is the result of the forward transform (see the next item). The destination matrix has the dft_size size and CV_32FC1 type. It contains the result of the inverse <a class="el" href="../../dc/de5/classcv_1_1cuda_1_1DFT.html" title="Base class for DFT operator as a cv::Algorithm. : ">DFT</a>.</li>
<li>If the source matrix is real (its type is CV_32FC1 ), forward <a class="el" href="../../dc/de5/classcv_1_1cuda_1_1DFT.html" title="Base class for DFT operator as a cv::Algorithm. : ">DFT</a> is performed. The result of the <a class="el" href="../../dc/de5/classcv_1_1cuda_1_1DFT.html" title="Base class for DFT operator as a cv::Algorithm. : ">DFT</a> is packed into complex ( CV_32FC2 ) matrix. So, the width of the destination matrix is dft_size.width / 2 + 1 . But if the source is a single column, the height is reduced instead of the width.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d88/group__cudaarithm__arithm.html#gadea99cb15a715c983bcc2870d65a2e78" title="Performs a forward or inverse discrete Fourier transform (1D or 2D) of the floating point matrix...">dft</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga42efe211d7a43bbc922da044c4f17130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::cuda::gemm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gab1371a23c90d5f4725ea98240377d7a1">InputArray</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gab1371a23c90d5f4725ea98240377d7a1">InputArray</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gab1371a23c90d5f4725ea98240377d7a1">InputArray</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html">Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html#a680af5adfeeb1cdaa5b7b13f680c0131">Stream::Null</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs generalized matrix multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>First multiplied input matrix that should have CV_32FC1 , CV_64FC1 , CV_32FC2 , or CV_64FC2 type. </td></tr>
    <tr><td class="paramname">src2</td><td>Second multiplied input matrix of the same type as src1 . </td></tr>
    <tr><td class="paramname">alpha</td><td>Weight of the matrix product. </td></tr>
    <tr><td class="paramname">src3</td><td>Third optional delta matrix added to the matrix product. It should have the same type as src1 and src2 . </td></tr>
    <tr><td class="paramname">beta</td><td>Weight of src3 . </td></tr>
    <tr><td class="paramname">dst</td><td>Destination matrix. It has the proper size and the same type as input matrices. </td></tr>
    <tr><td class="paramname">flags</td><td>Operation flags:<ul>
<li><b>GEMM_1_T</b> transpose src1</li>
<li><b>GEMM_2_T</b> transpose src2</li>
<li><b>GEMM_3_T</b> transpose src3 </li>
</ul>
</td></tr>
    <tr><td class="paramname">stream</td><td><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a> for the asynchronous version.</td></tr>
  </table>
  </dd>
</dl>
<p>The function performs generalized matrix multiplication similar to the gemm functions in BLAS level</p><ol type="1">
<li><p class="startli">For example, gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T) corresponds to</p>
<p class="formulaDsp">
\[\texttt{dst} = \texttt{alpha} \cdot \texttt{src1} ^T \cdot \texttt{src2} + \texttt{beta} \cdot \texttt{src3} ^T\]
</p>
</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Transposition operation doesn't support CV_64FC2 input type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d88/group__cudaarithm__arithm.html#ga42efe211d7a43bbc922da044c4f17130" title="Performs generalized matrix multiplication. ">gemm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5704c25b8be4f19da812e6d98c8ee464"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::cuda::mulAndScaleSpectrums </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gab1371a23c90d5f4725ea98240377d7a1">InputArray</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gab1371a23c90d5f4725ea98240377d7a1">InputArray</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjB</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html">Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html#a680af5adfeeb1cdaa5b7b13f680c0131">Stream::Null</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a per-element multiplication of two Fourier spectrums and scales the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>First spectrum. </td></tr>
    <tr><td class="paramname">src2</td><td>Second spectrum with the same size and type as a . </td></tr>
    <tr><td class="paramname">dst</td><td>Destination spectrum. </td></tr>
    <tr><td class="paramname">flags</td><td>Mock parameter used for CPU/CUDA interfaces similarity, simply add a <code>0</code> value. </td></tr>
    <tr><td class="paramname">scale</td><td>Scale constant. </td></tr>
    <tr><td class="paramname">conjB</td><td>Optional flag to specify if the second spectrum needs to be conjugated before the multiplication. </td></tr>
    <tr><td class="paramname">stream</td><td><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a> for the asynchronous version.</td></tr>
  </table>
  </dd>
</dl>
<p>Only full (not packed) CV_32FC2 complex spectrums in the interleaved format are supported for now.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d88/group__cudaarithm__arithm.html#gab3e8900d67c4f59bdc137a0495206cd8" title="Performs a per-element multiplication of two Fourier spectrums. ">mulSpectrums</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab3e8900d67c4f59bdc137a0495206cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::cuda::mulSpectrums </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gab1371a23c90d5f4725ea98240377d7a1">InputArray</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gab1371a23c90d5f4725ea98240377d7a1">InputArray</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>conjB</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html">Stream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em> = <code><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html#a680af5adfeeb1cdaa5b7b13f680c0131">Stream::Null</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a per-element multiplication of two Fourier spectrums. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src1</td><td>First spectrum. </td></tr>
    <tr><td class="paramname">src2</td><td>Second spectrum with the same size and type as a . </td></tr>
    <tr><td class="paramname">dst</td><td>Destination spectrum. </td></tr>
    <tr><td class="paramname">flags</td><td>Mock parameter used for CPU/CUDA interfaces similarity. </td></tr>
    <tr><td class="paramname">conjB</td><td>Optional flag to specify if the second spectrum needs to be conjugated before the multiplication. </td></tr>
    <tr><td class="paramname">stream</td><td><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a> for the asynchronous version.</td></tr>
  </table>
  </dd>
</dl>
<p>Only full (not packed) CV_32FC2 complex spectrums in the interleaved format are supported for now.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d88/group__cudaarithm__arithm.html#gab3e8900d67c4f59bdc137a0495206cd8" title="Performs a per-element multiplication of two Fourier spectrums. ">mulSpectrums</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 30 2017 10:44:42 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
<script type="text/javascript">
//<![CDATA[
function addButton(label, buttonName) {
    var b = document.createElement("BUTTON");
    b.innerHTML = buttonName;
    b.setAttribute('class', 'toggleable_button label_' + label);
    b.onclick = function() {
        $('.toggleable_button').css({
            border: '2px outset',
            'border-radius': '4px'
        });
        $('.toggleable_button.label_' + label).css({
            border: '2px inset',
            'border-radius': '4px'
        });
        $('.toggleable_div').css('display', 'none');
        $('.toggleable_div.label_' + label).css('display', 'block');
    };
    b.style.border = '2px outset';
    b.style.borderRadius = '4px';
    b.style.margin = '2px';
    return b;
}
function buttonsToAdd($elements, $heading, $type) {
    if ($elements.length === 0) {
        $elements = $("" + $type + ":contains(" + $heading.html() + ")").parent().prev("div.newInnerHTML");
    }
    var arr = jQuery.makeArray($elements);
    var seen = {};
    arr.forEach(function(e) {
        var txt = e.innerHTML;
        if (!seen[txt]) {
            $button = addButton(e.title, txt);
            if (Object.keys(seen).length == 0) {
                var linebreak1 = document.createElement("br");
                var linebreak2 = document.createElement("br");
                ($heading).append(linebreak1);
                ($heading).append(linebreak2);
            }
            ($heading).append($button);
            seen[txt] = true;
        }
    });
    return;
}
$("h2").each(function() {
    $heading = $(this);
    $smallerHeadings = $(this).nextUntil("h2").filter("h3").add($(this).nextUntil("h2").find("h3"));
    if ($smallerHeadings.length) {
        $smallerHeadings.each(function() {
            var $elements = $(this).nextUntil("h2,h3").filter("div.newInnerHTML");
            buttonsToAdd($elements, $(this), "h3");
        });
    } else {
        var $elements = $(this).nextUntil("h2").filter("div.newInnerHTML");
        buttonsToAdd($elements, $heading, "h2");
    }
});
$(".toggleable_button").first().click();
var $clickDefault = $('.toggleable_button.label_python').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
$clickDefault = $('.toggleable_button.label_cpp').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
//]]>
</script>
</body>
</html>
