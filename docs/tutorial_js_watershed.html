<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenCV: Image Segmentation with Watershed Algorithm</title>
<link href="opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">3.3.0-dev</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<script type="text/javascript">
//<![CDATA[
function getLabelName(innerHTML) {
    var str = innerHTML.toLowerCase();
    // Replace all '+' with 'p'
    str = str.split('+').join('p');
    // Replace all ' ' with '_'
    str = str.split(' ').join('_');
    // Replace all '#' with 'sharp'
    str = str.split('#').join('sharp');
    // Replace other special characters with 'ascii' + code
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (!(charCode == 95 || (charCode > 96 && charCode < 123) || (charCode > 47 && charCode < 58)))
            str = str.substr(0, i) + 'ascii' + charCode + str.substr(i + 1);
    }
    return str;
}
function addToggle() {
    var $getDiv = $('div.newInnerHTML').last();
    var buttonName = $getDiv.html();
    var label = getLabelName(buttonName.trim());
    $getDiv.attr("title", label);
    $getDiv.hide();
    $getDiv = $getDiv.next();
    $getDiv.attr("class", "toggleable_div label_" + label);
    $getDiv.hide();
}
//]]>
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="tutorial_js_root.html">OpenCV.js Tutorials</a></li><li class="navelem"><a class="el" href="tutorial_js_table_of_contents_imgproc.html">Image Processing</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Image Segmentation with Watershed Algorithm </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Goal </h2>
<ul>
<li>We will learn how to use marker-based image segmentation using watershed algorithm</li>
<li>We will learn: <b><a class="el" href="d7/d1b/group__imgproc__misc.html#ga3267243e4d3f95165d55a618c65ac6e1" title="Performs a marker-based image segmentation using the watershed algorithm. ">cv.watershed()</a></b></li>
</ul>
<h2>Theory </h2>
<p>Any grayscale image can be viewed as a topographic surface where high intensity denotes peaks and hills while low intensity denotes valleys. You start filling every isolated valleys (local minima) with different colored water (labels). As the water rises, depending on the peaks (gradients) nearby, water from different valleys, obviously with different colors will start to merge. To avoid that, you build barriers in the locations where water merges. You continue the work of filling water and building barriers until all the peaks are under water. Then the barriers you created gives you the segmentation result. This is the "philosophy" behind the watershed. You can visit the <a href="http://cmm.ensmp.fr/~beucher/wtshed.html">CMM webpage on watershed</a> to understand it with the help of some animations.</p>
<p>But this approach gives you oversegmented result due to noise or any other irregularities in the image. So OpenCV implemented a marker-based watershed algorithm where you specify which are all valley points are to be merged and which are not. It is an interactive image segmentation. What we do is to give different labels for our object we know. Label the region which we are sure of being the foreground or object with one color (or intensity), label the region which we are sure of being background or non-object with another color and finally the region which we are not sure of anything, label it with 0. That is our marker. Then apply watershed algorithm. Then our marker will be updated with the labels we gave, and the boundaries of objects will have a value of -1.</p>
<h2>Code </h2>
<p>Below we will see an example on how to use the Distance Transform along with watershed to segment mutually touching objects.</p>
<p>Consider the coins image below, the coins are touching each other. Even if you threshold it, it will be touching each other.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
.err {
    color: red;
}
</style>
</head>
<body>
<div id="imgCodeArea">
<h2>Image</h2>
</div>
<div id="imgShowcase">
    <div>
        <canvas id="imgCanvasInput"></canvas>
    </div>
    <input type="file" id="imgInput" name="file" />
</div>
<script src="utils.js"></script>
<script async src="opencv.js" id="opencvjs"></script>
<script>
loadImageToCanvas("coins.jpg", "imgCanvasInput");
let imgInputElement = document.getElementById("imgInput");
imgInputElement.addEventListener("change", imgHandleFiles, false);
function imgHandleFiles(e) {
    let imgUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(imgUrl, "imgCanvasInput");
}
</script>
</body>
</p>
<p>We start with finding an approximate estimate of the coins. For that, we can use the Otsu's binarization.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
</style>
</head>
<body>
<div id="thresholdCodeArea">
<p><strong>Threshold Image</strong></p>
<button id="thresholdTryIt" disabled="true" onclick="thresholdExecuteCode()">Try it</button><br>
<textarea rows="7" cols="80" id="thresholdTestCode" spellcheck="false">
let src = cv.imread("imgCanvasInput");
let dst = new cv.Mat(), gray = new cv.Mat();

// gray and threshold image
cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(gray, gray, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);

cv.imshow("thresholdCanvasOutput", gray);
src.delete(); dst.delete(); gray.delete();
</textarea>
<p class="err" id="thresholdErr"></p>
</div>
<div id="thresholdShowcase">
    <div>
        <canvas id="thresholdCanvasOutput"></canvas>
    </div>
</div>
<script>
function thresholdExecuteCode() {
    let thresholdText = document.getElementById("thresholdTestCode").value;
    try {
        eval(thresholdText);
        document.getElementById("thresholdErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("thresholdErr").innerHTML = err;
    }
}
</script>
</body>
</p>
<p>Now we need to remove any small white noises in the image. For that we can use morphological opening. To remove any small holes in the object, we can use morphological closing. So, now we know for sure that region near to center of objects are foreground and region much away from the object are background. Only region we are not sure is the boundary region of coins.</p>
<p>So we need to extract the area which we are sure they are coins. Erosion removes the boundary pixels. So whatever remaining, we can be sure it is coin. That would work if objects were not touching each other. But since they are touching each other, another good option would be to find the distance transform and apply a proper threshold. Next we need to find the area which we are sure they are not coins. For that, we dilate the result. Dilation increases object boundary to background. This way, we can make sure whatever region in background in result is really a background, since boundary region is removed. See the image below.</p>
<p> 
<!DOCTYPE html>
<head>
</head>
<body>
<div id="backgroundCodeArea">
<p><strong>Background</strong></p>
<button id="backgroundTryIt" disabled="true" onclick="backgroundExecuteCode()">Try it</button><br>
<textarea rows="13" cols="90" id="backgroundTestCode" spellcheck="false">
let src = cv.imread("imgCanvasInput");
let dst = new cv.Mat(), gray = new cv.Mat(), opening = new cv.Mat(), coinsBg = new cv.Mat();
cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(gray, gray, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);

// get background
let M = cv.Mat.ones(3, 3, cv.CV_8U);
cv.erode(gray, gray, M);
cv.dilate(gray, opening, M);
cv.dilate(opening, coinsBg, M, new cv.Point(-1, -1), 3);

cv.imshow("backgroundCanvasOutput", coinsBg);
src.delete(); dst.delete(); gray.delete(); opening.delete(); coinsBg.delete(); M.delete();
</textarea>
<p class="err" id="backgroundErr"></p>
</div>
<div id="backgroundShowcase">
    <div>
        <canvas id="backgroundCanvasOutput"></canvas>
    </div>
</div>
<script>
function backgroundExecuteCode() {
    let backgroundText = document.getElementById("backgroundTestCode").value;
    try {
        eval(backgroundText);
        document.getElementById("backgroundErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("backgroundErr").innerHTML = err;
    }
}
</script>
</body>
</p>
<p>The remaining regions are those which we don't have any idea, whether it is coins or background. Watershed algorithm should find it. These areas are normally around the boundaries of coins where foreground and background meet (Or even two different coins meet). We call it border. It can be obtained from subtracting sure_fg area from sure_bg area.</p>
<p>We use the function: <b><a class="el" href="d7/d1b/group__imgproc__misc.html#ga8a0b7fdfcb7a13dde018988ba3a43042" title="Calculates the distance to the closest zero pixel for each pixel of the source image. ">cv.distanceTransform</a> (src, dst, distanceType, maskSize, labelType = cv.CV_32F)</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>8-bit, single-channel (binary) source image. </td></tr>
    <tr><td class="paramname">dst</td><td>output image with calculated distances. It is a 8-bit or 32-bit floating-point, single-channel image of the same size as src. </td></tr>
    <tr><td class="paramname">distanceType</td><td>type of distance(see <a class="el" href="d7/d1b/group__imgproc__misc.html#gaa2bfbebbc5c320526897996aafa1d8eb">cv.DistanceTypes</a>). </td></tr>
    <tr><td class="paramname">maskSize</td><td>size of the distance transform mask, see (<a class="el" href="d7/d1b/group__imgproc__misc.html#gaaa68392323ccf7fad87570e41259b497" title="Mask size for distance transform. ">cv.DistanceTransformMasks</a>). </td></tr>
    <tr><td class="paramname">labelType</td><td>type of output image. It can be cv.CV_8U or cv.CV_32F. Type cv.CV_8U can be used only for the first variant of the function and distanceType == DIST_L1.</td></tr>
  </table>
  </dd>
</dl>
<p> 
<!DOCTYPE html>
<head>
</head>
<body>
<div id="distanceTransformCodeArea">
<p><strong>Distance Transform</strong></p>
<button id="distanceTransformTryIt" disabled="true" onclick="distanceTransformExecuteCode()">Try it</button><br>
<textarea rows="14" cols="90" id="distanceTransformTestCode" spellcheck="false">
let src = cv.imread("imgCanvasInput");
let dst = new cv.Mat(), gray = new cv.Mat(), opening = new cv.Mat(), coinsBg = new cv.Mat(), coinsFg = new cv.Mat(), distTrans = new cv.Mat();
cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(gray, gray, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
let M = cv.Mat.ones(3, 3, cv.CV_8U);
cv.erode(gray, gray, M);
cv.dilate(gray, opening, M);
cv.dilate(opening, coinsBg, M, new cv.Point(-1, -1), 3);

// distance transform
cv.distanceTransform(opening, distTrans, cv.DIST_L2, 5);
cv.normalize(distTrans, distTrans, 1, 0, cv.NORM_INF);

cv.imshow("distanceTransformCanvasOutput", distTrans);
src.delete(); dst.delete(); gray.delete(); opening.delete(); coinsBg.delete(); coinsFg.delete(); distTrans.delete(); M.delete();
</textarea>
<p class="err" id="distanceTransformErr"></p>
</div>
<div id="distanceTransformShowcase">
    <div>
        <canvas id="distanceTransformCanvasOutput"></canvas>
    </div>
</div>
<script>
function distanceTransformExecuteCode() {
    let distanceTransformText = document.getElementById("distanceTransformTestCode").value;
    try {
        eval(distanceTransformText);
        document.getElementById("distanceTransformErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("distanceTransformErr").innerHTML = err;
    }
}
</script>
</body>
</p>
<p>In the thresholded image, we get some regions of coins which we are sure of coins and they are detached now. (In some cases, you may be interested in only foreground segmentation, not in separating the mutually touching objects. In that case, you need not use distance transform, just erosion is sufficient. Erosion is just another method to extract sure foreground area, that's all.)</p>
<p> 
<!DOCTYPE html>
<head>
</head>
<body>
<div id="foregroundCodeArea">
<p><strong>Foreground</strong></p>
<button id="foregroundTryIt" disabled="true" onclick="foregroundExecuteCode()">Try it</button><br>
<textarea rows="15" cols="90" id="foregroundTestCode" spellcheck="false">
let src = cv.imread("imgCanvasInput");
let dst = new cv.Mat(), gray = new cv.Mat(), opening = new cv.Mat(), coinsBg = new cv.Mat(), coinsFg = new cv.Mat(), distTrans = new cv.Mat();
cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(gray, gray, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
let M = cv.Mat.ones(3, 3, cv.CV_8U);
cv.erode(gray, gray, M);
cv.dilate(gray, opening, M);
cv.dilate(opening, coinsBg, M, new cv.Point(-1, -1), 3);
cv.distanceTransform(opening, distTrans, cv.DIST_L2, 5);
cv.normalize(distTrans, distTrans, 1, 0, cv.NORM_INF);

// get foreground
cv.threshold(distTrans, coinsFg, 0.7 * 1, 255, cv.THRESH_BINARY);

cv.imshow("foregroundCanvasOutput", coinsFg);
src.delete(); dst.delete(); gray.delete(); opening.delete(); coinsBg.delete(); coinsFg.delete(); distTrans.delete(); M.delete();
</textarea>
<p class="err" id="foregroundErr"></p>
</div>
<div id="foregroundShowcase">
    <div>
        <canvas id="foregroundCanvasOutput"></canvas>
    </div>
</div>
<script>
function foregroundExecuteCode() {
    let foregroundText = document.getElementById("foregroundTestCode").value;
    try {
        eval(foregroundText);
        document.getElementById("foregroundErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("foregroundErr").innerHTML = err;
    }
}
</script>
</body>
</p>
<p>Now we know for sure which are region of coins, which are background and all. So we create marker (it is an array of same size as that of original image, but with int32 datatype) and label the regions inside it. The regions we know for sure (whether foreground or background) are labelled with any positive integers, but different integers, and the area we don't know for sure are just left as zero. For this we use <b><a class="el" href="d3/dc0/group__imgproc__shape.html#gaedef8c7340499ca391d459122e51bef5" title="computes the connected components labeled image of boolean image ">cv.connectedComponents()</a></b>. It labels background of the image with 0, then other objects are labelled with integers starting from 1.</p>
<p>But we know that if background is marked with 0, watershed will consider it as unknown area. So we want to mark it with different integer. Instead, we will mark unknown region, defined by unknown, with 0.</p>
<p>Now our marker is ready. It is time for final step, apply watershed. Then marker image will be modified. The boundary region will be marked with -1.</p>
<p>We use the function: <b><a class="el" href="d3/dc0/group__imgproc__shape.html#gaedef8c7340499ca391d459122e51bef5" title="computes the connected components labeled image of boolean image ">cv.connectedComponents</a> (image, labels, connectivity = 8, ltype = cv.CV_32S)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>the 8-bit single-channel image to be labeled. </td></tr>
    <tr><td class="paramname">labels</td><td>destination labeled image(cv.CV_32SC1 type). </td></tr>
    <tr><td class="paramname">connectivity</td><td>8 or 4 for 8-way or 4-way connectivity respectively. </td></tr>
    <tr><td class="paramname">ltype</td><td>output image label type. Currently cv.CV_32S and cv.CV_16U are supported.</td></tr>
  </table>
  </dd>
</dl>
<p>We use the function: <b><a class="el" href="d7/d1b/group__imgproc__misc.html#ga3267243e4d3f95165d55a618c65ac6e1" title="Performs a marker-based image segmentation using the watershed algorithm. ">cv.watershed</a> (image, markers)</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>input 8-bit 3-channel image. </td></tr>
    <tr><td class="paramname">markers</td><td>input/output 32-bit single-channel image (map) of markers. It should have the same size as image .</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Try this demo using the code above. Canvas elements named watershedCanvasInput and watershedCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. You can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
</head>
<body>
<div id="watershedCodeArea">
<h2>Input your code</h2>
<button id="watershedTryIt" disabled="true" onclick="watershedExecuteCode()">Try it</button><br>
<textarea rows="25" cols="90" id="watershedTestCode" spellcheck="false">
let src = cv.imread("watershedCanvasInput");
let dst = new cv.Mat(), gray = new cv.Mat(), opening = new cv.Mat(), coinsBg = new cv.Mat(), coinsFg = new cv.Mat(), distTrans = new cv.Mat(), unknown = new cv.Mat(), markers = new cv.Mat();
// gray and threshold image
cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
cv.threshold(gray, gray, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
// get background
let M = cv.Mat.ones(3, 3, cv.CV_8U);
cv.erode(gray, gray, M);
cv.dilate(gray, opening, M);
cv.dilate(opening, coinsBg, M, new cv.Point(-1, -1), 3);
// distance transform
cv.distanceTransform(opening, distTrans, cv.DIST_L2, 5);
cv.normalize(distTrans, distTrans, 1, 0, cv.NORM_INF);
// get foreground
cv.threshold(distTrans, coinsFg, 0.7 * 1, 255, cv.THRESH_BINARY);
coinsFg.convertTo(coinsFg, cv.CV_8U, 1, 0);
cv.subtract(coinsBg, coinsFg, unknown);
// get connected components markers
cv.connectedComponents(coinsFg, markers);
for (let i = 0; i < markers.rows; i++)
    for (let j = 0; j < markers.cols; j++) {
        markers.intPtr(i, j)[0] = markers.ucharPtr(i, j)[0] + 1;
        if (unknown.ucharPtr(i, j)[0] == 255) {
            markers.intPtr(i, j)[0] = 0;
        }
    }
cv.cvtColor(src, src, cv.COLOR_RGBA2RGB, 0);
cv.watershed(src, markers);
// draw barriers
for (let i = 0; i < markers.rows; i++)
    for (let j = 0; j < markers.cols; j++) {
        if (markers.intPtr(i, j)[0] == -1) {
            src.ucharPtr(i, j)[0] = 255;  //R
            src.ucharPtr(i, j)[1] = 0;    //G
            src.ucharPtr(i, j)[2] = 0;    //B
        }
    }
cv.imshow("watershedCanvasOutput", src);
src.delete(); dst.delete(); gray.delete(); opening.delete(); coinsBg.delete(); coinsFg.delete(); distTrans.delete(); unknown.delete(); markers.delete(); M.delete();
</textarea>
<p class="err" id="watershedErr"></p>
</div>
<div id="watershedShowcase">
    <div>
        <canvas id="watershedCanvasInput"></canvas>
        <canvas id="watershedCanvasOutput"></canvas>
    </div>
    <input type="file" id="watershedInput" name="file" />
</div>
<script>
function watershedExecuteCode() {
    let watershedText = document.getElementById("watershedTestCode").value;
    try {
        eval(watershedText);
        document.getElementById("watershedErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("watershedErr").innerHTML = err;
    }
}

loadImageToCanvas("coins.jpg", "watershedCanvasInput");
let watershedInputElement = document.getElementById("watershedInput");
watershedInputElement.addEventListener("change", watershedHandleFiles, false);
function watershedHandleFiles(e) {
    let watershedUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(watershedUrl, "watershedCanvasInput");
}

function onReady() {
    document.getElementById("thresholdTryIt").disabled = false;
    document.getElementById("backgroundTryIt").disabled = false;
    document.getElementById("distanceTransformTryIt").disabled = false;
    document.getElementById("foregroundTryIt").disabled = false;
    document.getElementById("watershedTryIt").disabled = false;
}
if (typeof cv !== 'undefined') {
    onReady();
} else {
    document.getElementById("opencvjs").onload = onReady;
}
</script>
</body>
 </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 30 2017 10:44:42 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
<script type="text/javascript">
//<![CDATA[
function addButton(label, buttonName) {
    var b = document.createElement("BUTTON");
    b.innerHTML = buttonName;
    b.setAttribute('class', 'toggleable_button label_' + label);
    b.onclick = function() {
        $('.toggleable_button').css({
            border: '2px outset',
            'border-radius': '4px'
        });
        $('.toggleable_button.label_' + label).css({
            border: '2px inset',
            'border-radius': '4px'
        });
        $('.toggleable_div').css('display', 'none');
        $('.toggleable_div.label_' + label).css('display', 'block');
    };
    b.style.border = '2px outset';
    b.style.borderRadius = '4px';
    b.style.margin = '2px';
    return b;
}
function buttonsToAdd($elements, $heading, $type) {
    if ($elements.length === 0) {
        $elements = $("" + $type + ":contains(" + $heading.html() + ")").parent().prev("div.newInnerHTML");
    }
    var arr = jQuery.makeArray($elements);
    var seen = {};
    arr.forEach(function(e) {
        var txt = e.innerHTML;
        if (!seen[txt]) {
            $button = addButton(e.title, txt);
            if (Object.keys(seen).length == 0) {
                var linebreak1 = document.createElement("br");
                var linebreak2 = document.createElement("br");
                ($heading).append(linebreak1);
                ($heading).append(linebreak2);
            }
            ($heading).append($button);
            seen[txt] = true;
        }
    });
    return;
}
$("h2").each(function() {
    $heading = $(this);
    $smallerHeadings = $(this).nextUntil("h2").filter("h3").add($(this).nextUntil("h2").find("h3"));
    if ($smallerHeadings.length) {
        $smallerHeadings.each(function() {
            var $elements = $(this).nextUntil("h2,h3").filter("div.newInnerHTML");
            buttonsToAdd($elements, $(this), "h3");
        });
    } else {
        var $elements = $(this).nextUntil("h2").filter("div.newInnerHTML");
        buttonsToAdd($elements, $heading, "h2");
    }
});
$(".toggleable_button").first().click();
var $clickDefault = $('.toggleable_button.label_python').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
$clickDefault = $('.toggleable_button.label_cpp').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
//]]>
</script>
</body>
</html>
