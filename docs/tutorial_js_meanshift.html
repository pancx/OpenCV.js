<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenCV: Meanshift and Camshift</title>
<link href="opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">3.3.0-dev</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<script type="text/javascript">
//<![CDATA[
function getLabelName(innerHTML) {
    var str = innerHTML.toLowerCase();
    // Replace all '+' with 'p'
    str = str.split('+').join('p');
    // Replace all ' ' with '_'
    str = str.split(' ').join('_');
    // Replace all '#' with 'sharp'
    str = str.split('#').join('sharp');
    // Replace other special characters with 'ascii' + code
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (!(charCode == 95 || (charCode > 96 && charCode < 123) || (charCode > 47 && charCode < 58)))
            str = str.substr(0, i) + 'ascii' + charCode + str.substr(i + 1);
    }
    return str;
}
function addToggle() {
    var $getDiv = $('div.newInnerHTML').last();
    var buttonName = $getDiv.html();
    var label = getLabelName(buttonName.trim());
    $getDiv.attr("title", label);
    $getDiv.hide();
    $getDiv = $getDiv.next();
    $getDiv.attr("class", "toggleable_div label_" + label);
    $getDiv.hide();
}
//]]>
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="tutorial_js_root.html">OpenCV.js Tutorials</a></li><li class="navelem"><a class="el" href="tutorial_js_table_of_contents_video.html">Video Analysis</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Meanshift and Camshift </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Goal </h2>
<ul>
<li>We will learn about Meanshift and Camshift algorithms to find and track objects in videos.</li>
</ul>
<h2>Meanshift </h2>
<p>The intuition behind the meanshift is simple. Consider you have a set of points. (It can be a pixel distribution like histogram backprojection). You are given a small window ( may be a circle) and you have to move that window to the area of maximum pixel density (or maximum number of points). It is illustrated in the simple image given below:</p>
<div class="image">
<img src="meanshift_basics.jpg" alt="meanshift_basics.jpg"/>
<div class="caption">
image</div></div>
<p> The initial window is shown in blue circle with the name "C1". Its original center is marked in blue rectangle, named "C1_o". But if you find the centroid of the points inside that window, you will get the point "C1_r" (marked in small blue circle) which is the real centroid of window. Surely they don't match. So move your window such that circle of the new window matches with previous centroid. Again find the new centroid. Most probably, it won't match. So move it again, and continue the iterations such that center of window and its centroid falls on the same location (or with a small desired error). So finally what you obtain is a window with maximum pixel distribution. It is marked with green circle, named "C2". As you can see in image, it has maximum number of points. The whole process is demonstrated on a static image below:</p>
<div class="image">
<img src="meanshift_face.gif" alt="meanshift_face.gif"/>
<div class="caption">
image</div></div>
<p> So we normally pass the histogram backprojected image and initial target location. When the object moves, obviously the movement is reflected in histogram backprojected image. As a result, meanshift algorithm moves our window to the new location with maximum density.</p>
<h3>Meanshift in OpenCV.js</h3>
<p>To use meanshift in OpenCV.js, first we need to setup the target, find its histogram so that we can backproject the target on each frame for calculation of meanshift. We also need to provide initial location of window. For histogram, only Hue is considered here. Also, to avoid false values due to low light, low light values are discarded using <b><a class="el" href="d2/de8/group__core__array.html#ga48af0ab51e36436c5d04340e036ce981" title="Checks if array elements lie between the elements of two other arrays. ">cv.inRange()</a></b> function.</p>
<p>We use the function: <b><a class="el" href="dc/d6b/group__video__track.html#ga432a563c94eaf179533ff1e83dbb65ea" title="Finds an object on a back projection image. ">cv.meanShift</a> (probImage, window, criteria)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probImage</td><td>Back projection of the object histogram. See <a class="el" href="d6/dc7/group__imgproc__hist.html#ga3a0af640716b456c3d14af8aee12e3ca" title="Calculates the back projection of a histogram. ">cv.calcBackProject</a> for details. </td></tr>
    <tr><td class="paramname">window</td><td>Initial search window. </td></tr>
    <tr><td class="paramname">criteria</td><td>Stop criteria for the iterative search algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of iterations meanShift took to converge and the new location</dd></dl>
<h3>Try it</h3>
<p>Try this demo for <a class="el" href="dc/d6b/group__video__track.html#ga432a563c94eaf179533ff1e83dbb65ea" title="Finds an object on a back projection image. ">cv.meanShift</a>. Some core code is in the textbox, and you can click <code>try it</code> to investigate more.</p>
<p> 
<head>
<style>
canvas {
    border: 1px solid black;
}
.err {
    color: red;
}
</style>
</head>
<body>

<div id="CodeArea">
<h3>Input your code</h3>
<textarea rows="30" cols="90" id="msTestCode" spellcheck="false">
// Mats used in the loop are all declared and deleted elsewhere
// take first frame of the video
msFrame = new cv.Mat(msHeight, msWidth, cv.CV_8UC4);
let cap = new cv.VideoCapture("msVideo"); // "msVideo" is the id of the video tag
cap.read(msFrame);

// setup initial location of window
let trackWindow = new cv.Rect(300, 120, 125, 250); // simply hardcoded the values 300, 120, 125, 250

// set up the ROI for tracking
let msRoi = msFrame.roi(trackWindow);
let msHsvRoi = new cv.Mat();
cv.cvtColor(msRoi, msHsvRoi, cv.COLOR_RGBA2RGB);
cv.cvtColor(msHsvRoi, msHsvRoi, cv.COLOR_RGB2HSV);
let mask = new cv.Mat();
let lowScalar = new cv.Scalar(30, 30, 0);
let highScalar = new cv.Scalar(180, 180, 180);
let low = new cv.Mat(msHsvRoi.rows, msHsvRoi.cols, msHsvRoi.type(), lowScalar);
let high = new cv.Mat(msHsvRoi.rows, msHsvRoi.cols, msHsvRoi.type(), highScalar);
cv.inRange(msHsvRoi, low, high, mask);
msRoiHist = new cv.Mat();
let msHsvRoiVec = new cv.MatVector();
msHsvRoiVec.push_back(msHsvRoi);
cv.calcHist(msHsvRoiVec, [0], mask, msRoiHist, [180], [0,180]);
cv.normalize(msRoiHist, msRoiHist, 0, 255, cv.NORM_MINMAX);

// delete useless mats.
msRoi.delete(); msHsvRoi.delete(); mask.delete(); low.delete(); high.delete(); msHsvRoiVec.delete();

// Setup the termination criteria, either 10 iteration or move by atleast 1 pt
let termCrit = new cv.TermCriteria(cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, 10, 1);

msHsv = new cv.Mat(msHeight, msWidth, cv.CV_8UC3);
msDst = new cv.Mat();
msHsvVec = new cv.MatVector();
msHsvVec.push_back(msHsv);
msLoopIndex = setInterval(
    function() {
        if(msVideo.ended) {
            msStopVideo();
            return;
        }
        cap.read(msFrame);
        cv.cvtColor(msFrame, msHsv, cv.COLOR_RGBA2RGB);
        cv.cvtColor(msHsv, msHsv, cv.COLOR_RGB2HSV);
        cv.calcBackProject(msHsvVec, [0], msRoiHist, msDst, [0,180], 1);

        // Apply meanshift to get the new location
        // and it also returns number of iterations meanShift took to converge,
        // which is useless in this demo.
        [ , trackWindow] = cv.meanShift(msDst, trackWindow, termCrit);

        // Draw it on image
        let [x,y,w,h] = [trackWindow.x, trackWindow.y, trackWindow.width, trackWindow.height];
        cv.rectangle(msFrame, new cv.Point(x, y), new cv.Point(x+w, y+h), [255, 0, 0, 255], 2);
        cv.imshow("msCanvasOutput", msFrame);
    }, 33);
</textarea>
<p class="err" id="msErr"></p>
</div>
<div id="contentarea">
    <button id="msStartup" disabled="true" onclick="msStartup()">try it</button>
    <button id="msStop" disabled="true" onclick="msStopVideo()">stop</button><br>
    <video id="msVideo" src="cup.mp4" width="640" muted hidden>Your browser does not support the video tag.</video>
    <canvas id="msCanvasOutput"></canvas>
</div>
<script async src="opencv.js" id="opencvjs"></script>
<script>
// ms means Meanshift
// Some HTML elements we need to configure.
let msVideo = document.getElementById("msVideo");
let msStop = document.getElementById("msStop");

// In this case, We set width 640, and the height will be computed based on the input video.
let msWidth = msVideo.width;
let msHeight = null;
let msLoopIndex = null;
let msFrame = null;
let msDst = null;
let msHsvVec = null;
let msRoiHist = null;

msVideo.oncanplay = function() {
    msVideo.setAttribute("height", msVideo.videoHeight/msVideo.videoWidth*msVideo.width);
    msHeight = msVideo.height;
};

msVideo.onended = msStopVideo;

function msStartup() {
    if(msVideo.readyState !== 4)
        msVideo.load();
    msVideo.play();
    msStop.disabled = false;

    let msTestCode = document.getElementById("msTestCode").value;
    try {
        eval(msTestCode);
        document.getElementById("msErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("msErr").innerHTML = err;
    }
    document.getElementById("msStartup").disabled = true;
}

function msStopVideo() {
    clearInterval(msLoopIndex);
    if (msFrame != null && !msFrame.isDeleted()) {
        msFrame.delete();
        msFrame = null;
    }
    if (msDst != null && !msDst.isDeleted()) {
        msDst.delete();
        msDst = null;
    }
    if (msHsvVec != null && !msHsvVec.isDeleted()) {
        msHsvVec.delete();
        msHsvVec = null;
    }
    if (msRoiHist != null && !msRoiHist.isDeleted()) {
        msRoiHist.delete();
        msRoiHist = null;
    }
    if (msHsv != null && !msHsv.isDeleted()) {
        msHsv.delete();
        msHsv = null;
    }
    //document.getElementById("msCanvasOutput").getContext("2d").clearRect(0, 0, msWidth, msHeight);
    msVideo.pause();
    msVideo.currentTime = 0;
    document.getElementById("msStartup").disabled = false;
}
</script>
</body>
</p>
<h2>Camshift </h2>
<p>Did you closely watch the last result? There is a problem. Our window always has the same size when the object is farther away and it is very close to camera. That is not good. We need to adapt the window size with size and rotation of the target. Once again, the solution came from "OpenCV Labs" and it is called CAMshift (Continuously Adaptive Meanshift) published by Gary Bradsky in his paper "Computer Vision Face Tracking for Use in a Perceptual User Interface" in 1988.</p>
<p>It applies meanshift first. Once meanshift converges, it updates the size of the window as, \(s = 2 \times \sqrt{\frac{M_{00}}{256}}\). It also calculates the orientation of best fitting ellipse to it. Again it applies the meanshift with new scaled search window and previous window location. The process is continued until required accuracy is met.</p>
<div class="image">
<img src="camshift_face.gif" alt="camshift_face.gif"/>
<div class="caption">
image</div></div>
 <h3>Camshift in OpenCV.js</h3>
<p>It is almost same as meanshift, but it returns a rotated rectangle (that is our result) and box parameters (used to be passed as search window in next iteration).</p>
<p>We use the function: <b><a class="el" href="dc/d6b/group__video__track.html#gaef2bd39c8356f423124f1fe7c44d54a1" title="Finds an object center, size, and orientation. ">cv.CamShift</a> (probImage, window, criteria)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probImage</td><td>Back projection of the object histogram. See <a class="el" href="d6/dc7/group__imgproc__hist.html#ga3a0af640716b456c3d14af8aee12e3ca" title="Calculates the back projection of a histogram. ">cv.calcBackProject</a> for details. </td></tr>
    <tr><td class="paramname">window</td><td>Initial search window. </td></tr>
    <tr><td class="paramname">criteria</td><td>Stop criteria for the iterative search algorithm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rotated rectangle and the new search window</dd></dl>
<h3>Try it</h3>
<p>Try this demo for <a class="el" href="dc/d6b/group__video__track.html#gaef2bd39c8356f423124f1fe7c44d54a1" title="Finds an object center, size, and orientation. ">cv.CamShift</a>. Some core code is in the textbox, and you can click <code>try it</code> to investigate more.</p>
<p> 
<head>
<style>
canvas {
    border: 1px solid black;
}
.err {
    color: red;
}
</style>
</head>
<body>

<div id="CodeArea">
<h3>Input your code</h3>
<textarea rows="30" cols="90" id="csTestCode" spellcheck="false">
// Mats used in the loop are all declared and deleted elsewhere
// take first frame of the video
csFrame = new cv.Mat(csHeight, csWidth, cv.CV_8UC4);
let cap = new cv.VideoCapture("csVideo"); // "csVideo" is the id of the video tag
cap.read(csFrame);

// setup initial location of window
let trackWindow = new cv.Rect(300, 120, 125, 250); // simply hardcoded the values 300, 120, 125, 250

// set up the ROI for tracking
let csRoi = csFrame.roi(trackWindow);
let csHsvRoi = new cv.Mat();
cv.cvtColor(csRoi, csHsvRoi, cv.COLOR_RGBA2RGB);
cv.cvtColor(csHsvRoi, csHsvRoi, cv.COLOR_RGB2HSV);
let mask = new cv.Mat();
let lowScalar = new cv.Scalar(30, 30, 0);
let highScalar = new cv.Scalar(180, 180, 180);
let low = new cv.Mat(csHsvRoi.rows, csHsvRoi.cols, csHsvRoi.type(), lowScalar);
let high = new cv.Mat(csHsvRoi.rows, csHsvRoi.cols, csHsvRoi.type(), highScalar);
cv.inRange(csHsvRoi, low, high, mask);
csRoiHist = new cv.Mat();
let csHsvRoiVec = new cv.MatVector();
csHsvRoiVec.push_back(csHsvRoi);
cv.calcHist(csHsvRoiVec, [0], mask, csRoiHist, [180], [0,180]);
cv.normalize(csRoiHist, csRoiHist, 0, 255, cv.NORM_MINMAX);

// delete useless mats.
csRoi.delete(); csHsvRoi.delete(); mask.delete(); low.delete(); high.delete(); csHsvRoiVec.delete();

// Setup the termination criteria, either 10 iteration or move by atleast 1 pt
let termCrit = new cv.TermCriteria(cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, 10, 1);

csHsv = new cv.Mat(csHeight, csWidth, cv.CV_8UC3);
csHsvVec = new cv.MatVector();
csHsvVec.push_back(csHsv);
csDst = new cv.Mat();
let trackBox = null;
csLoopIndex = setInterval(
    function() {
        if(csVideo.ended) {
            csStopVideo();
            return;
        }
        cap.read(csFrame);
        cv.cvtColor(csFrame, csHsv, cv.COLOR_RGBA2RGB);
        cv.cvtColor(csHsv, csHsv, cv.COLOR_RGB2HSV);
        cv.calcBackProject(csHsvVec, [0], csRoiHist, csDst, [0,180], 1);

        // apply camshift to get the new location
        [trackBox, trackWindow] = cv.CamShift(csDst, trackWindow, termCrit);

        // Draw it on image
        let pts = cv.rotatedRectPoints(trackBox);
        cv.line(csFrame, pts[0], pts[1], [255, 0, 0, 255], 3);
        cv.line(csFrame, pts[1], pts[2], [255, 0, 0, 255], 3);
        cv.line(csFrame, pts[2], pts[3], [255, 0, 0, 255], 3);
        cv.line(csFrame, pts[3], pts[0], [255, 0, 0, 255], 3);
        cv.imshow("csCanvasOutput", csFrame);
    }, 33);
</textarea>
<p class="err" id="csErr"></p>
</div>
<div id="contentarea">
    <button id="csStartup" disabled="true" onclick="csStartup()">try it</button>
    <button id="csStop" disabled="true" onclick="csStopVideo()">stop</button><br>
    <video id="csVideo" src="cup.mp4" width="640" muted hidden>Your browser does not support the video tag.</video>
    <canvas id="csCanvasOutput"></canvas>
</div>
<script>
// cs means Camshift
// Some HTML elements we need to configure.
let csVideo = document.getElementById("csVideo");
let csStop = document.getElementById("csStop");

// In this case, We set width 640, and the height will be computed based on the input video.
let csWidth = csVideo.width;
let csHeight = null;
let csLoopIndex = null;
let csFrame = null;
let csDst = null;
let csHsvVec = null;
let csHsv = null;
let csRoiHist = null;

csVideo.oncanplay = function() {
    csVideo.setAttribute("height", csVideo.videoHeight/csVideo.videoWidth*csVideo.width);
    csHeight = csVideo.height;
};

csVideo.onended = csStopVideo;

function csStartup() {
    if(csVideo.readyState !== 4)
        csVideo.load();
    csVideo.play();
    csStop.disabled = false;
    let csTestCode = document.getElementById("csTestCode").value;
    try {
        eval(csTestCode);
        document.getElementById("csErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("csErr").innerHTML = err;
    }
    document.getElementById("csStartup").disabled = true;
}

function csStopVideo() {
    clearInterval(csLoopIndex);
    if (csFrame != null && !csFrame.isDeleted()) {
        csFrame.delete();
        csFrame = null;
    }
    if (csDst != null && !csDst.isDeleted()) {
        csDst.delete();
        csDst = null;
    }
    if (csHsvVec != null && !csHsvVec.isDeleted()) {
        csHsvVec.delete();
        csHsvVec = null;
    }
    if (csRoiHist != null && !csRoiHist.isDeleted()) {
        csRoiHist.delete();
        csRoiHist = null;
    }
    if (csHsv != null && !csHsv.isDeleted()) {
        csHsv.delete();
        csHsv = null;
    }
    //document.getElementById("csCanvasOutput").getContext("2d").clearRect(0, 0, csWidth, csHeight);
    csVideo.pause();
    csVideo.currentTime = 0;
    document.getElementById("csStartup").disabled = false;
}

function onReady() {
    document.getElementById("msStartup").disabled = false;
    document.getElementById("csStartup").disabled = false;
}
if (typeof cv !== 'undefined') {
    onReady();
} else {
    document.getElementById("opencvjs").onload = onReady;
}
</script>
</body>
</p>
<h2>Additional Resources </h2>
<ol type="1">
<li>French Wikipedia page on <a href="http://fr.wikipedia.org/wiki/Camshift">Camshift</a>. (The two animations are taken from here)</li>
<li>Bradski, G.R., "Real time face and object tracking as a component of a perceptual user
    interface," Applications of Computer Vision, 1998. WACV '98. Proceedings., Fourth IEEE Workshop on , vol., no., pp.214,219, 19-21 Oct 1998 </li>
</ol>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 30 2017 10:44:42 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
<script type="text/javascript">
//<![CDATA[
function addButton(label, buttonName) {
    var b = document.createElement("BUTTON");
    b.innerHTML = buttonName;
    b.setAttribute('class', 'toggleable_button label_' + label);
    b.onclick = function() {
        $('.toggleable_button').css({
            border: '2px outset',
            'border-radius': '4px'
        });
        $('.toggleable_button.label_' + label).css({
            border: '2px inset',
            'border-radius': '4px'
        });
        $('.toggleable_div').css('display', 'none');
        $('.toggleable_div.label_' + label).css('display', 'block');
    };
    b.style.border = '2px outset';
    b.style.borderRadius = '4px';
    b.style.margin = '2px';
    return b;
}
function buttonsToAdd($elements, $heading, $type) {
    if ($elements.length === 0) {
        $elements = $("" + $type + ":contains(" + $heading.html() + ")").parent().prev("div.newInnerHTML");
    }
    var arr = jQuery.makeArray($elements);
    var seen = {};
    arr.forEach(function(e) {
        var txt = e.innerHTML;
        if (!seen[txt]) {
            $button = addButton(e.title, txt);
            if (Object.keys(seen).length == 0) {
                var linebreak1 = document.createElement("br");
                var linebreak2 = document.createElement("br");
                ($heading).append(linebreak1);
                ($heading).append(linebreak2);
            }
            ($heading).append($button);
            seen[txt] = true;
        }
    });
    return;
}
$("h2").each(function() {
    $heading = $(this);
    $smallerHeadings = $(this).nextUntil("h2").filter("h3").add($(this).nextUntil("h2").find("h3"));
    if ($smallerHeadings.length) {
        $smallerHeadings.each(function() {
            var $elements = $(this).nextUntil("h2,h3").filter("div.newInnerHTML");
            buttonsToAdd($elements, $(this), "h3");
        });
    } else {
        var $elements = $(this).nextUntil("h2").filter("div.newInnerHTML");
        buttonsToAdd($elements, $heading, "h2");
    }
});
$(".toggleable_button").first().click();
var $clickDefault = $('.toggleable_button.label_python').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
$clickDefault = $('.toggleable_button.label_cpp').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
//]]>
</script>
</body>
</html>
