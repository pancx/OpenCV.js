<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenCV: Morphological Transformations</title>
<link href="opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">3.3.0-dev</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<script type="text/javascript">
//<![CDATA[
function getLabelName(innerHTML) {
    var str = innerHTML.toLowerCase();
    // Replace all '+' with 'p'
    str = str.split('+').join('p');
    // Replace all ' ' with '_'
    str = str.split(' ').join('_');
    // Replace all '#' with 'sharp'
    str = str.split('#').join('sharp');
    // Replace other special characters with 'ascii' + code
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (!(charCode == 95 || (charCode > 96 && charCode < 123) || (charCode > 47 && charCode < 58)))
            str = str.substr(0, i) + 'ascii' + charCode + str.substr(i + 1);
    }
    return str;
}
function addToggle() {
    var $getDiv = $('div.newInnerHTML').last();
    var buttonName = $getDiv.html();
    var label = getLabelName(buttonName.trim());
    $getDiv.attr("title", label);
    $getDiv.hide();
    $getDiv = $getDiv.next();
    $getDiv.attr("class", "toggleable_div label_" + label);
    $getDiv.hide();
}
//]]>
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="tutorial_js_root.html">OpenCV.js Tutorials</a></li><li class="navelem"><a class="el" href="tutorial_js_table_of_contents_imgproc.html">Image Processing</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Morphological Transformations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Goal </h2>
<ul>
<li>We will learn different morphological operations like Erosion, Dilation, Opening, Closing etc.</li>
<li>We will learn different functions like : <b><a class="el" href="d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb" title="Erodes an image by using a specific structuring element. ">cv.erode()</a></b>, <b><a class="el" href="d4/d86/group__imgproc__filter.html#ga4ff0f3318642c4f469d0e11f242f3b6c" title="Dilates an image by using a specific structuring element. ">cv.dilate()</a></b>, <b><a class="el" href="d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f" title="Performs advanced morphological transformations. ">cv.morphologyEx()</a></b> etc.</li>
</ul>
<h2>Theory </h2>
<p>Morphological transformations are some simple operations based on the image shape. It is normally performed on binary images. It needs two inputs, one is our original image, second one is called <b>structuring element</b> or <b>kernel</b> which decides the nature of operation. Two basic morphological operators are Erosion and Dilation. Then its variant forms like Opening, Closing, Gradient etc also comes into play. We will see them one-by-one with help of following image:</p>
<div class="image">
<img src="shape.jpg" alt="shape.jpg"/>
<div class="caption">
image</div></div>
 <h3>1. Erosion</h3>
<p>The basic idea of erosion is just like soil erosion only, it erodes away the boundaries of foreground object (Always try to keep foreground in white). So what it does? The kernel slides through the image (as in 2D convolution). A pixel in the original image (either 1 or 0) will be considered 1 only if all the pixels under the kernel is 1, otherwise it is eroded (made to zero).</p>
<p>So what happends is that, all the pixels near boundary will be discarded depending upon the size of kernel. So the thickness or size of the foreground object decreases or simply white region decreases in the image. It is useful for removing small white noises (as we have seen in colorspace chapter), detach two connected objects etc.</p>
<p>We use the function: <b><a class="el" href="d4/d86/group__imgproc__filter.html#gaeb1e0c1033e3f6b891a25d0511362aeb" title="Erodes an image by using a specific structuring element. ">cv.erode</a> (src, dst, kernel, anchor = new <a class="el" href="dc/d84/group__core__basic.html#ga1e83eafb2d26b3c93f09e8338bcab192">cv.Point</a>(-1, -1), iterations = 1, borderType = <a class="el" href="d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aed2e4346047e265c8c5a6d0276dcd838" title="iiiiii|abcdefgh|iiiiiii with some specified i ">cv.BORDER_CONSTANT</a>, borderValue = <a class="el" href="d4/d86/group__imgproc__filter.html#ga94756fad83d9d24d29c9bf478558c40a" title="returns &quot;magic&quot; border value for erosion and dilation. It is automatically transformed to Scalar::all...">cv.morphologyDefaultBorderValue()</a>)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>input image; the number of channels can be arbitrary, but the depth should be one of cv.CV_8U, cv.CV_16U, cv.CV_16S, cv.CV_32F or cv.CV_64F. </td></tr>
    <tr><td class="paramname">dst</td><td>output image of the same size and type as src. </td></tr>
    <tr><td class="paramname">kernel</td><td>structuring element used for erosion. </td></tr>
    <tr><td class="paramname">anchor</td><td>position of the anchor within the element; default value new <a class="el" href="dc/d84/group__core__basic.html#ga1e83eafb2d26b3c93f09e8338bcab192">cv.Point</a>(-1, -1) means that the anchor is at the element center. </td></tr>
    <tr><td class="paramname">iterations</td><td>number of times erosion is applied. </td></tr>
    <tr><td class="paramname">borderType</td><td>pixel extrapolation method(see <a class="el" href="d2/de8/group__core__array.html#ga209f2f4869e304c82d07739337eae7c5">cv.BorderTypes</a>). </td></tr>
    <tr><td class="paramname">borderValue</td><td>border value in case of a constant border</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Try this demo using the code above. Canvas elements named erodeCanvasInput and erodeCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. You can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
<style>
canvas {
    border: 1px solid black;
}
.err{
    color: red;
}
</style>
</head>
<body>
<div id="erodeCodeArea">
<h2>Input your code</h2>
<button id="erodeTryIt" disabled="true" onclick="erodeExecuteCode()">Try it</button><br>
<textarea rows="9" cols="90" id="erodeTestCode" spellcheck="false">
let src = cv.imread("erodeCanvasInput");
let dst = new cv.Mat();
let M = cv.Mat.ones(5, 5, cv.CV_8U);
let anchor = new cv.Point(-1, -1);
// You can try more different parameters
cv.erode(src, dst, M, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());
cv.imshow("erodeCanvasOutput", dst);
src.delete(); dst.delete(); M.delete();
</textarea>
<p class="err" id="erodeErr"></p>
</div>
<div id="erodeShowcase">
    <div>
        <canvas id="erodeCanvasInput"></canvas>
        <canvas id="erodeCanvasOutput"></canvas>
    </div>
    <input type="file" id="erodeInput" name="file" />
</div>
<script src="utils.js"></script>
<script async src="opencv.js" id="opencvjs"></script>
<script>
function erodeExecuteCode() {
    let erodeText = document.getElementById("erodeTestCode").value;
    try {
        eval(erodeText);
        document.getElementById("erodeErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("erodeErr").innerHTML = err;
    }
}

loadImageToCanvas("shape.jpg", "erodeCanvasInput");
let erodeInputElement = document.getElementById("erodeInput");
erodeInputElement.addEventListener("change", erodeHandleFiles, false);
function erodeHandleFiles(e) {
    let erodeUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(erodeUrl, "erodeCanvasInput");
}
</script>
</body>
</p>
<h3>2. Dilation</h3>
<p>It is just opposite of erosion. Here, a pixel element is '1' if atleast one pixel under the kernel is '1'. So it increases the white region in the image or size of foreground object increases. Normally, in cases like noise removal, erosion is followed by dilation. Because, erosion removes white noises, but it also shrinks our object. So we dilate it. Since noise is gone, they won't come back, but our object area increases. It is also useful in joining broken parts of an object.</p>
<p>We use the function: <b><a class="el" href="d4/d86/group__imgproc__filter.html#ga4ff0f3318642c4f469d0e11f242f3b6c" title="Dilates an image by using a specific structuring element. ">cv.dilate</a> (src, dst, kernel, anchor = new <a class="el" href="dc/d84/group__core__basic.html#ga1e83eafb2d26b3c93f09e8338bcab192">cv.Point</a>(-1, -1), iterations = 1, borderType = <a class="el" href="d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aed2e4346047e265c8c5a6d0276dcd838" title="iiiiii|abcdefgh|iiiiiii with some specified i ">cv.BORDER_CONSTANT</a>, borderValue = <a class="el" href="d4/d86/group__imgproc__filter.html#ga94756fad83d9d24d29c9bf478558c40a" title="returns &quot;magic&quot; border value for erosion and dilation. It is automatically transformed to Scalar::all...">cv.morphologyDefaultBorderValue()</a>)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>input image; the number of channels can be arbitrary, but the depth should be one of cv.CV_8U, cv.CV_16U, cv.CV_16S, cv.CV_32F or cv.CV_64F. </td></tr>
    <tr><td class="paramname">dst</td><td>output image of the same size and type as src. </td></tr>
    <tr><td class="paramname">kernel</td><td>structuring element used for dilation. </td></tr>
    <tr><td class="paramname">anchor</td><td>position of the anchor within the element; default value new <a class="el" href="dc/d84/group__core__basic.html#ga1e83eafb2d26b3c93f09e8338bcab192">cv.Point</a>(-1, -1) means that the anchor is at the element center. </td></tr>
    <tr><td class="paramname">iterations</td><td>number of times dilation is applied. </td></tr>
    <tr><td class="paramname">borderType</td><td>pixel extrapolation method(see <a class="el" href="d2/de8/group__core__array.html#ga209f2f4869e304c82d07739337eae7c5">cv.BorderTypes</a>). </td></tr>
    <tr><td class="paramname">borderValue</td><td>border value in case of a constant border</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Try this demo using the code above. Canvas elements named dilateCanvasInput and dilateCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. You can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
</head>
<body>
<div id="dilateCodeArea">
<h2>Input your code</h2>
<button id="dilateTryIt" disabled="true" onclick="dilateExecuteCode()">Try it</button><br>
<textarea rows="8" cols="90" id="dilateTestCode" spellcheck="false">
let src = cv.imread("dilateCanvasInput");
let dst = new cv.Mat();
let M = cv.Mat.ones(5, 5, cv.CV_8U);
let anchor = new cv.Point(-1, -1);
// You can try more different parameters
cv.dilate(src, dst, M, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());
cv.imshow("dilateCanvasOutput", dst);
src.delete(); dst.delete(); M.delete();
</textarea>
<p class="err" id="dilateErr"></p>
</div>
<div id="dilateShowcase">
    <div>
        <canvas id="dilateCanvasInput"></canvas>
        <canvas id="dilateCanvasOutput"></canvas>
    </div>
    <input type="file" id="dilateInput" name="file" />
</div>
<script>
function dilateExecuteCode() {
    let dilateText = document.getElementById("dilateTestCode").value;
    try {
        eval(dilateText);
        document.getElementById("dilateErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("dilateErr").innerHTML = err;
    }
}

loadImageToCanvas("shape.jpg", "dilateCanvasInput");
let dilateInputElement = document.getElementById("dilateInput");
dilateInputElement.addEventListener("change", dilateHandleFiles, false);
function dilateHandleFiles(e) {
    let dilateUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(dilateUrl, "dilateCanvasInput");
}
</script>
</body>
</p>
<h3>3. Opening</h3>
<p>Opening is just another name of <b>erosion followed by dilation</b>. It is useful in removing noise.</p>
<p>We use the function: <b><a class="el" href="d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f" title="Performs advanced morphological transformations. ">cv.morphologyEx</a> (src, dst, op, kernel, anchor = new <a class="el" href="dc/d84/group__core__basic.html#ga1e83eafb2d26b3c93f09e8338bcab192">cv.Point</a>(-1, -1), iterations = 1, borderType = <a class="el" href="d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aed2e4346047e265c8c5a6d0276dcd838" title="iiiiii|abcdefgh|iiiiiii with some specified i ">cv.BORDER_CONSTANT</a>, borderValue = <a class="el" href="d4/d86/group__imgproc__filter.html#ga94756fad83d9d24d29c9bf478558c40a" title="returns &quot;magic&quot; border value for erosion and dilation. It is automatically transformed to Scalar::all...">cv.morphologyDefaultBorderValue()</a>)</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source image. The number of channels can be arbitrary. The depth should be one of cv.CV_8U, cv.CV_16U, cv.CV_16S, cv.CV_32F or cv.CV_64F </td></tr>
    <tr><td class="paramname">dst</td><td>destination image of the same size and type as source image. </td></tr>
    <tr><td class="paramname">op</td><td>type of a morphological operation, (see <a class="el" href="d4/d86/group__imgproc__filter.html#ga7be549266bad7b2e6a04db49827f9f32" title="type of morphological operation ">cv.MorphTypes</a>). </td></tr>
    <tr><td class="paramname">kernel</td><td>structuring element. It can be created using <a class="el" href="d4/d86/group__imgproc__filter.html#gac342a1bb6eabf6f55c803b09268e36dc" title="Returns a structuring element of the specified size and shape for morphological operations. ">cv.getStructuringElement</a>. </td></tr>
    <tr><td class="paramname">anchor</td><td>anchor position with the kernel. Negative values mean that the anchor is at the kernel center. </td></tr>
    <tr><td class="paramname">iterations</td><td>number of times dilation is applied. </td></tr>
    <tr><td class="paramname">borderType</td><td>pixel extrapolation method(see <a class="el" href="d2/de8/group__core__array.html#ga209f2f4869e304c82d07739337eae7c5">cv.BorderTypes</a>). </td></tr>
    <tr><td class="paramname">borderValue</td><td>border value in case of a constant border. The default value has a special meaning.</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Try this demo using the code above. Canvas elements named openingCanvasInput and openingCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. You can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
</head>
<body>
<div id="openingCodeArea">
<h2>Input your code</h2>
<button id="openingTryIt" disabled="true" onclick="openingExecuteCode()">Try it</button><br>
<textarea rows="8" cols="90" id="openingTestCode" spellcheck="false">
let src = cv.imread("openingCanvasInput");
let dst = new cv.Mat();
let M = cv.Mat.ones(5, 5, cv.CV_8U);
let anchor = new cv.Point(-1, -1);
// You can try more different parameters
cv.morphologyEx(src, dst, cv.MORPH_OPEN, M, anchor, 1, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue());
cv.imshow("openingCanvasOutput", dst);
src.delete(); dst.delete(); M.delete();
</textarea>
<p class="err" id="openingErr"></p>
</div>
<div id="openingShowcase">
    <div>
        <canvas id="openingCanvasInput"></canvas>
        <canvas id="openingCanvasOutput"></canvas>
    </div>
    <input type="file" id="openingInput" name="file" />
</div>
<script>
function openingExecuteCode() {
    let openingText = document.getElementById("openingTestCode").value;
    try {
        eval(openingText);
        document.getElementById("openingErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("openingErr").innerHTML = err;
    }
}

loadImageToCanvas("shape.jpg", "openingCanvasInput");
let openingInputElement = document.getElementById("openingInput");
openingInputElement.addEventListener("change", openingHandleFiles, false);
function openingHandleFiles(e) {
    let openingUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(openingUrl, "openingCanvasInput");
}
</script>
</body>
</p>
<h3>4. Closing</h3>
<p>Closing is reverse of Opening, <b>Dilation followed by Erosion</b>. It is useful in closing small holes inside the foreground objects, or small black points on the object.</p>
<h2>Try it </h2>
<p>Try this demo using the code above. Canvas elements named closingCanvasInput and closingCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. You can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
</head>
<body>
<div id="closingCodeArea">
<h2>Input your code</h2>
<button id="closingTryIt" disabled="true" onclick="closingExecuteCode()">Try it</button><br>
<textarea rows="8" cols="90" id="closingTestCode" spellcheck="false">
let src = cv.imread("closingCanvasInput");
let dst = new cv.Mat();
let M = cv.Mat.ones(5, 5, cv.CV_8U);
// You can try more different parameters
cv.morphologyEx(src, dst, cv.MORPH_CLOSE, M);
cv.imshow("closingCanvasOutput", dst);
src.delete(); dst.delete(); M.delete();
</textarea>
<p class="err" id="closingErr"></p>
</div>
<div id="closingShowcase">
    <div>
        <canvas id="closingCanvasInput"></canvas>
        <canvas id="closingCanvasOutput"></canvas>
    </div>
    <input type="file" id="closingInput" name="file" />
</div>
<script>
function closingExecuteCode() {
    let closingText = document.getElementById("closingTestCode").value;
    try {
        eval(closingText);
        document.getElementById("closingErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("closingErr").innerHTML = err;
    }
}

loadImageToCanvas("shape.jpg", "closingCanvasInput");
let closingInputElement = document.getElementById("closingInput");
closingInputElement.addEventListener("change", closingHandleFiles, false);
function closingHandleFiles(e) {
    let closingUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(closingUrl, "closingCanvasInput");
}
</script>
</body>
</p>
<h3>5. Morphological Gradient</h3>
<p>It is the difference between dilation and erosion of an image.</p>
<p>The result will look like the outline of the object.</p>
<h2>Try it </h2>
<p>Try this demo using the code above. Canvas elements named gradientCanvasInput and gradientCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. You can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
</head>
<body>
<div id="gradientCodeArea">
<h2>Input your code</h2>
<button id="gradientTryIt" disabled="true" onclick="gradientExecuteCode()">Try it</button><br>
<textarea rows="8" cols="90" id="gradientTestCode" spellcheck="false">
let src = cv.imread("gradientCanvasInput");
cv.cvtColor(src, src, cv.COLOR_RGBA2RGB);
let dst = new cv.Mat();
let M = cv.Mat.ones(5, 5, cv.CV_8U);
// You can try more different parameters
cv.morphologyEx(src, dst, cv.MORPH_GRADIENT, M);
cv.imshow("gradientCanvasOutput", dst);
src.delete(); dst.delete(); M.delete();
</textarea>
<p class="err" id="gradientErr"></p>
</div>
<div id="gradientShowcase">
    <div>
        <canvas id="gradientCanvasInput"></canvas>
        <canvas id="gradientCanvasOutput"></canvas>
    </div>
    <input type="file" id="gradientInput" name="file" />
</div>
<script>
function gradientExecuteCode() {
    let gradientText = document.getElementById("gradientTestCode").value;
    try {
        eval(gradientText);
        document.getElementById("gradientErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("gradientErr").innerHTML = err;
    }
}

loadImageToCanvas("shape.jpg", "gradientCanvasInput");
let gradientInputElement = document.getElementById("gradientInput");
gradientInputElement.addEventListener("change", gradientHandleFiles, false);
function gradientHandleFiles(e) {
    let gradientUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(gradientUrl, "gradientCanvasInput");
}
</script>
</body>
</p>
<h3>6. Top Hat</h3>
<p>It is the difference between input image and Opening of the image.</p>
<h2>Try it </h2>
<p>Try this demo using the code above. Canvas elements named topHatCanvasInput and topHatCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. You can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
</head>
<body>
<div id="topHatCodeArea">
<h2>Input your code</h2>
<button id="topHatTryIt" disabled="true" onclick="topHatExecuteCode()">Try it</button><br>
<textarea rows="8" cols="90" id="topHatTestCode" spellcheck="false">
let src = cv.imread("topHatCanvasInput");
cv.cvtColor(src, src, cv.COLOR_RGBA2RGB);
let dst = new cv.Mat();
let M = cv.Mat.ones(9, 9, cv.CV_8U);
// You can try more different parameters
cv.morphologyEx(src, dst, cv.MORPH_TOPHAT, M);
cv.imshow("topHatCanvasOutput", dst);
src.delete(); dst.delete(); M.delete();
</textarea>
<p class="err" id="topHatErr"></p>
</div>
<div id="topHatShowcase">
    <div>
        <canvas id="topHatCanvasInput"></canvas>
        <canvas id="topHatCanvasOutput"></canvas>
    </div>
    <input type="file" id="topHatInput" name="file" />
</div>
<script>
function topHatExecuteCode() {
    let topHatText = document.getElementById("topHatTestCode").value;
    try {
        eval(topHatText);
        document.getElementById("topHatErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("topHatErr").innerHTML = err;
    }
}

loadImageToCanvas("shape.jpg", "topHatCanvasInput");
let topHatInputElement = document.getElementById("topHatInput");
topHatInputElement.addEventListener("change", topHatHandleFiles, false);
function topHatHandleFiles(e) {
    let topHatUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(topHatUrl, "topHatCanvasInput");
}
</script>
</body>
</p>
<h3>7. Black Hat</h3>
<p>It is the difference between the closing of the input image and input image.</p>
<h2>Try it </h2>
<p>Try this demo using the code above. Canvas elements named blackHatCanvasInput and blackHatCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. You can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
</head>
<body>
<div id="blackHatCodeArea">
<h2>Input your code</h2>
<button id="blackHatTryIt" disabled="true" onclick="blackHatExecuteCode()">Try it</button><br>
<textarea rows="8" cols="90" id="blackHatTestCode" spellcheck="false">
let src = cv.imread("blackHatCanvasInput");
cv.cvtColor(src, src, cv.COLOR_RGBA2RGB);
let dst = new cv.Mat();
let M = cv.Mat.ones(53, 53, cv.CV_8U);
// You can try more different parameters
cv.morphologyEx(src, dst, cv.MORPH_BLACKHAT, M);
cv.imshow("blackHatCanvasOutput", dst);
src.delete(); dst.delete(); M.delete();
</textarea>
<p class="err" id="blackHatErr"></p>
</div>
<div id="blackHatShowcase">
    <div>
        <canvas id="blackHatCanvasInput"></canvas>
        <canvas id="blackHatCanvasOutput"></canvas>
    </div>
    <input type="file" id="blackHatInput" name="file" />
</div>
<script>
function blackHatExecuteCode() {
    let blackHatText = document.getElementById("blackHatTestCode").value;
    try {
        eval(blackHatText);
        document.getElementById("blackHatErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("blackHatErr").innerHTML = err;
    }
}

loadImageToCanvas("shape.jpg", "blackHatCanvasInput");
let blackHatInputElement = document.getElementById("blackHatInput");
blackHatInputElement.addEventListener("change", blackHatHandleFiles, false);
function blackHatHandleFiles(e) {
    let blackHatUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(blackHatUrl, "blackHatCanvasInput");
}
</script>
</body>
</p>
<h2>Structuring Element </h2>
<p>We manually created a structuring elements in the previous examples with help of <a class="el" href="d3/d63/classcv_1_1Mat.html#a69ae0402d116fc9c71908d8508dc2f09" title="Returns an array of all 1&#39;s of the specified size and type. ">cv.Mat.ones</a>. It is rectangular shape. But in some cases, you may need elliptical/circular shaped kernels. So for this purpose, OpenCV has a function, <b><a class="el" href="d4/d86/group__imgproc__filter.html#gac342a1bb6eabf6f55c803b09268e36dc" title="Returns a structuring element of the specified size and shape for morphological operations. ">cv.getStructuringElement()</a></b>. You just pass the shape and size of the kernel, you get the desired kernel.</p>
<p>We use the function: <b><a class="el" href="d4/d86/group__imgproc__filter.html#gac342a1bb6eabf6f55c803b09268e36dc" title="Returns a structuring element of the specified size and shape for morphological operations. ">cv.getStructuringElement</a> (shape, ksize, anchor = new <a class="el" href="dc/d84/group__core__basic.html#ga1e83eafb2d26b3c93f09e8338bcab192">cv.Point</a>(-1, -1))</b> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>element shape that could be one of <a class="el" href="d4/d86/group__imgproc__filter.html#gac2db39b56866583a95a5680313c314ad" title="shape of the structuring element ">cv.MorphShapes</a> </td></tr>
    <tr><td class="paramname">ksize</td><td>size of the structuring element. </td></tr>
    <tr><td class="paramname">anchor</td><td>anchor position within the element. The default value [−1,−1] means that the anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor position. In other cases the anchor just regulates how much the result of the morphological operation is shifted.</td></tr>
  </table>
  </dd>
</dl>
<h2>Try it </h2>
<p>Try this demo using the code above. Canvas elements named getStructuringElementCanvasInput and getStructuringElementCanvasOutput have been prepared. Choose an image and click <code>Try it</code> to see the result. You can change the code in the textbox to investigate more.</p>
<p> 
<!DOCTYPE html>
<head>
</head>
<body>
<div id="getStructuringElementCodeArea">
<h2>Input your code</h2>
<button id="getStructuringElementTryIt" disabled="true" onclick="getStructuringElementExecuteCode()">Try it</button><br>
<textarea rows="10" cols="90" id="getStructuringElementTestCode" spellcheck="false">
let src = cv.imread("getStructuringElementCanvasInput");
cv.cvtColor(src, src, cv.COLOR_RGBA2RGB);
let dst = new cv.Mat();
let M = new cv.Mat();
let ksize = new cv.Size(5, 5);
// You can try more different parameters
M = cv.getStructuringElement(cv.MORPH_CROSS, ksize);
cv.morphologyEx(src, dst, cv.MORPH_GRADIENT, M);
cv.imshow("getStructuringElementCanvasOutput", dst);
src.delete(); dst.delete(); M.delete();
</textarea>
<p class="err" id="getStructuringElementErr"></p>
</div>
<div id="getStructuringElementShowcase">
    <div>
        <canvas id="getStructuringElementCanvasInput"></canvas>
        <canvas id="getStructuringElementCanvasOutput"></canvas>
    </div>
    <input type="file" id="getStructuringElementInput" name="file" />
</div>
<script>
function getStructuringElementExecuteCode() {
    let getStructuringElementText = document.getElementById("getStructuringElementTestCode").value;
    try {
        eval(getStructuringElementText);
        document.getElementById("getStructuringElementErr").innerHTML = " ";
    } catch(err) {
        document.getElementById("getStructuringElementErr").innerHTML = err;
    }
}

loadImageToCanvas("shape.jpg", "getStructuringElementCanvasInput");
let getStructuringElementInputElement = document.getElementById("getStructuringElementInput");
getStructuringElementInputElement.addEventListener("change", getStructuringElementHandleFiles, false);
function getStructuringElementHandleFiles(e) {
    let getStructuringElementUrl = URL.createObjectURL(e.target.files[0]);
    loadImageToCanvas(getStructuringElementUrl, "getStructuringElementCanvasInput");
}
function onReady() {
    document.getElementById("dilateTryIt").disabled = false;
    document.getElementById("erodeTryIt").disabled = false;
    document.getElementById("openingTryIt").disabled = false;
    document.getElementById("closingTryIt").disabled = false;
    document.getElementById("gradientTryIt").disabled = false;
    document.getElementById("topHatTryIt").disabled = false;
    document.getElementById("blackHatTryIt").disabled = false;
    document.getElementById("getStructuringElementTryIt").disabled = false;
}
if (typeof cv !== 'undefined') {
    onReady();
} else {
    document.getElementById("opencvjs").onload = onReady;
}
</script>
</body>
 </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 30 2017 10:44:42 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
<script type="text/javascript">
//<![CDATA[
function addButton(label, buttonName) {
    var b = document.createElement("BUTTON");
    b.innerHTML = buttonName;
    b.setAttribute('class', 'toggleable_button label_' + label);
    b.onclick = function() {
        $('.toggleable_button').css({
            border: '2px outset',
            'border-radius': '4px'
        });
        $('.toggleable_button.label_' + label).css({
            border: '2px inset',
            'border-radius': '4px'
        });
        $('.toggleable_div').css('display', 'none');
        $('.toggleable_div.label_' + label).css('display', 'block');
    };
    b.style.border = '2px outset';
    b.style.borderRadius = '4px';
    b.style.margin = '2px';
    return b;
}
function buttonsToAdd($elements, $heading, $type) {
    if ($elements.length === 0) {
        $elements = $("" + $type + ":contains(" + $heading.html() + ")").parent().prev("div.newInnerHTML");
    }
    var arr = jQuery.makeArray($elements);
    var seen = {};
    arr.forEach(function(e) {
        var txt = e.innerHTML;
        if (!seen[txt]) {
            $button = addButton(e.title, txt);
            if (Object.keys(seen).length == 0) {
                var linebreak1 = document.createElement("br");
                var linebreak2 = document.createElement("br");
                ($heading).append(linebreak1);
                ($heading).append(linebreak2);
            }
            ($heading).append($button);
            seen[txt] = true;
        }
    });
    return;
}
$("h2").each(function() {
    $heading = $(this);
    $smallerHeadings = $(this).nextUntil("h2").filter("h3").add($(this).nextUntil("h2").find("h3"));
    if ($smallerHeadings.length) {
        $smallerHeadings.each(function() {
            var $elements = $(this).nextUntil("h2,h3").filter("div.newInnerHTML");
            buttonsToAdd($elements, $(this), "h3");
        });
    } else {
        var $elements = $(this).nextUntil("h2").filter("div.newInnerHTML");
        buttonsToAdd($elements, $heading, "h2");
    }
});
$(".toggleable_button").first().click();
var $clickDefault = $('.toggleable_button.label_python').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
$clickDefault = $('.toggleable_button.label_cpp').first();
if ($clickDefault.length) {
    $clickDefault.click();
}
//]]>
</script>
</body>
</html>
